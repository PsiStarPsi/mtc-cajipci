\documentclass[12pt]{article}


\begin{document}


\title{DSP\_cPCI Device Driver Documentation}
\author{ Serge Negrashov, Andrew Wong \\
	 Department of Physics and Astronomy,\\
	 University of Hawaii, 2505 Correa Road,\\
	 Honolulu, HI 96822, USA
}
\date{March 2011}
\maketitle

\tableofcontents

\section{Introduction}

The DSP\_cPCI is a compact PCI device that is intended to facilitate the data acquisition from various devices connected to it.  This is done by storing data on an on-board buffer (256k as of writing this document) and having the devices read or write data to this buffer.

\section{PCI board operation}

I/O is controlled via a pointer (address register) to the buffer.  This pointer is automatically incremented whenever a read or write is performed. 

The board seems to use a circular buffer of sorts - when the end of the buffer is reached, it wraps around back to the beginning of the buffer.  It is unsure whether this is intentional or not, either from the firmware or device driver perspective.

% However, when the pointer reaches the end of the buffer, interesting behavior occurs.  If a read (write hasn't been tested as of yet, but isn't a priority) would push the pointer past the end of the buffer, the readout is truncated so that the end of the buffer is the end of the readout (e.g. if the pointer is 8 bytes from the end, and a read command is sent for 16 bytes, a read for 8 bytes is returned)  Also, if a read command is performed after this, the readout will read out the beginning of the buffer.  This 'feature', although likely unintentional, is useful in the upcoming software correction.

\section{PCI device driver}

(TODO: ask Serge, possibly others to verify this)

The device driver is written as a linux kernel module (*.ko), as a character device.  The linux functions open, read, write, release, and llseek are implemented in the kernel module.

Requirements for installation:

\begin{itemize}
\item Source files for device driver
\item Header files for appropriate linux distro (standard requirement for kernel modules)
\end{itemize}

A script (chardev\_load.sh) is provided which installs the kernel module.  For the installation, run it from the parent directory (since that is where the .ko file gets generated).

Also note that both for kernel module installation as well as data readout, root access is required (e.g. run as superuser or with sudo).

\section{Linux device driver design}

The device driver is implemented as a character device in /dev.  The elegance of such an implementation is that it allows abstraction for the end-user during testing, since such a device can be read/written to like a regular file.

Implementation consists of three layers:

\begin{itemize}
\item Hardware-level calls.  This consists of functions that directly deal with the hardware, as well as maintaining the state of known PCI cards attached to the system.
\item Chardev device.  This consists of implementing the main chardev functions used by the linux kernel: read, write, open, and release, as well as others.
\item Userland code.  This is the library class that a user would use to interface and access the PCI devices in the system.  Many of the chardev functions are abstracted from the end-user for simplicity.
\end{itemize}

\subsection{Hardware-level calls}

At the lowest level, data is read in from the PCI interface via PCI function calls.  This is handled via the open/release and read/write functions. 

Read and write for the non-DMA version is done by gaining access to a PCI buffer via a PCI system call, then doing copying appropriate memory to/from this buffer whenever a read or write is performed.  This is later extended to multiple cards, where the buffer pointers of multiple cards are stored.

In order to handle the possibility of an unknown number of PCI cards being installed in the system, the information about the PCI cards is stored as a linked list within the kernel structure.  

I/O and locking is done via either card number or ID.  Card number is largely used for testing where number is based on the card's position in the linked list structure.  Card ID, on the other hand, is based on the six-bit value assigned to the card via the dip switches on the card itself.  By using these values, it should be possible to distinguish multiple PCI cards in the system.

\subsection{chardev}

The chardev device is implemented under /dev/altixpci0 as a character device (hence 'chardev').  

The chardev device can be treated like a regular file - accessed via the open/close system calls, seeked with the lseek call, and read/written to with the read/write calls.  As a character device, chardev implements the following character device functions:

\subsubsection{open}
Opens the device.  By default, no PCI card is selected as the active card.

\subsubsection{read}
Reads data from a PCI device

\subsubsection{write}
Writes data from a PCI device

\subsubsection{lseek}
Moves pointer to buffer of PCI device.

\subsubsection{ioctl}
Handles various auxiliary functions for the device.  The following ioctl calls are implemented:

\begin{itemize}
\item ALTIX\_IOCTL\_NUM: returns the number of PCI cards currently managed by the driver.
\item ALTIX\_IOCTL\_INFO: returns an array of altix\_pci\_card\_info (card id, process ID of card currently using card, and memory length) objects.  Memory should be allocated prior to calling this function - to determine how much memory to allocate, the previous ioctl function can be used.
\item ALTIX\_IOCTL\_LOCK: associates the current card with the given process.  Note that if a fork is performed, only one of the resulting processes will maintain the lock on the card, since locks are PID-based.
\item ALTIX\_IOCTL\_RELEASE: releases a lock from the previous command.
\item ALTIX\_IOCTL\_STAT: retrieves read/write stats for PCI cards
\end{itemize}


\section{libaltix user-land library}



\end{document}
